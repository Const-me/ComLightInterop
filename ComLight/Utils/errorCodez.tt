<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Text.RegularExpressions" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Runtime.InteropServices" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ output extension=".cs" #>using System.Collections.Generic;

namespace ComLight
{
	// This part of the class is automatically generated by a T4 template, by parsing C headers in ComLightLib and in Windows SDK
	static partial class ErrorCodes
	{
		static readonly Dictionary<int, string> codes = new Dictionary<int, string>()<#
			string dirNativeProject = Host.ResolvePath( "../../ComLightLib" );
			parseErrorCodes( dirNativeProject, this );
			#>;
	}
}<#+
// Parsing C headers with regular expressions. What could possibly go wrong?

const string pathWinError = @"C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\shared\winerror.h";

// Read a text file line by line, return non-empty lines
static IEnumerable<string> readFile( string path )
{
	using( var fs = File.OpenRead( path ) )
	using( var sr = new StreamReader( fs ) )
	{
		while( true )
		{
			string line = sr.ReadLine();
			if( null == line )
				yield break;
			if( string.IsNullOrWhiteSpace( line ) )
				continue;
			yield return line;
		}
	}
}

// Try to match string against a regular expression which captures 2 groups. If matched, return true and get the groups.
static bool tryMatchRegEx( string line, Regex re, out string key, out string val )
{
	var m = re.Match( line );
	if( !m.Success )
	{
		key = null;
		val = null;
		return false;
	}
	key = m.Groups[ 1 ].Value;
	val = m.Groups[ 2 ].Value;
	return true;
}

// Match e.g. "constexpr HRESULT OLE_E_BLANK = _HRESULT_TYPEDEF_( 0x80040007 );", capture OLE_E_BLANK and 80040007
static readonly Regex reHresultHex = new Regex( @"constexpr\s+HRESULT\s+(\S+)\s*=\s*_HRESULT_TYPEDEF_\s*\(\s*0x([0-9A-Fa-f]+)[Ll]?\s*\)\s*;" );
// Match e.g. "constexpr HRESULT E_EOF = HRESULT_FROM_WIN32( ERROR_HANDLE_EOF );", capture E_EOF and ERROR_HANDLE_EOF
static readonly Regex reHresultWin32 = new Regex( @"constexpr\s+HRESULT\s+(\S+)\s*=\s*HRESULT_FROM_WIN32\s*\(\s*(\S+)\s*\)\s*;" );

class Error
{
	public readonly string message, symbol;
	public Error( string m, string s ) { message = m; symbol = s; }
}

static void addError( Dictionary<int, Error> dict, int hr, string symbol )
{
	// Too lazy to parse error text from Windows headers.
	// This T4 runs on my PC, it's Windows 10 with en-us system locale, so I have FormatMessage API available and it retruns good enough messages.
	// FormatMessage API is exposed to .NET as Marshal.GetExceptionForHR, among others.
	Exception ex = Marshal.GetExceptionForHR( hr );
	dict.Add( hr, new Error( ex.Message, symbol ) );
}

static int HRESULT_FROM_WIN32( int w32 )
{
	if( w32 < 0 )
		return w32;
	return ( w32 & 0xFFFF ) | unchecked( ( int ) 0x80070000 );
}

static void tryParseCode( string line, Dictionary<int, Error> result )
{
	string k, v;
	if( tryMatchRegEx( line, reHresultHex, out k, out v ) )
	{
		addError( result, Convert.ToInt32( v, 16 ), k );
		return;
	}
	if( tryMatchRegEx( line, reHresultWin32, out k, out v ) )
	{
		if( !winError.ContainsKey( v ) )
			throw new KeyNotFoundException( v );
		addError( result, HRESULT_FROM_WIN32( winError[ v ] ), k );
		return;
	}
}

// Match e.g. "#define ERROR_ACCESS_DENIED  5L", capture ERROR_ACCESS_DENIED and 5
static readonly Regex reWinError = new Regex( @"^#define\s+(\S+)\s+([0-9]+)[Ll]?\s*$" );

// Parse winerror.h SDK header, produce dictionary where key = symbol, value = numeric code
static Dictionary<string, int> parseWinError()
{
	var res = new Dictionary<string, int>();
	foreach( string line in readFile( pathWinError ) )
	{
		string k, v;
		if( tryMatchRegEx( line, reWinError, out k, out v ) )
			res.Add( k, int.Parse( v ) );
	}
	return res;
}
static readonly Dictionary<string, int> winError = parseWinError();

// Slightly fix error messages, e.g. we don't want "(Exception from HRESULT: ...)" part
static string makeErrorMessage( string str )
{
	int idx = str.IndexOf( "(Exception from HRESULT:" );
	if( idx > 0 )
		str = str.Substring( 0, idx );
	return str.Trim().TrimEnd( '.', ' ', '\t' );
}

static void parseErrorCodes( string dir, TextTransformation p )
{
	var codes = new Dictionary<int, Error>();

	foreach( var path in Directory.GetFiles( dir, "*.h", SearchOption.AllDirectories ) )
	{
		foreach( string line in readFile( path ) )
		{
			tryParseCode( line, codes );
		}
	}
	if( codes.Count <= 0 )
	{
		p.Write( "{ }" );
		return;
	}
	p.WriteLine( "" );
	p.WriteLine( "\t\t{" );
	foreach( var kvp in codes )
		p.WriteLine( "\t\t\t{{ unchecked( (int)0x{0:X} ), \"{1}\" }},  // {2}", kvp.Key,  makeErrorMessage( kvp.Value.message ), kvp.Value.symbol );
	p.Write( "\t\t}" );
}
#>