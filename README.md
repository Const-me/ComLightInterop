This repository contains crossplatform COM interop library for .NET core.# MotivationI’m programming C++ and C#, often in the same project. Both languages are object oriented, and yet outside Windows there’s no easy way to consume objects across the native/managed boundary. When an API only has a few methods, C interop is fine. But as the API surface grows, supporting wrappers on both sides of the interop becomes time consuming and error prone. This project solves it by allowing to interop directly through OO APIs.# Technical DetailsThe C++ interop library is in the ComLightLib library. It implements a few template classes, providing functionality comparable to a small subset of [ATL](https://en.wikipedia.org/wiki/Active_Template_Library).When building on Linux, that library is header only, you don’t actually need to build it. On Windows there’s one .cpp file, server\freeThreadedMarshaller.cpp, required for better interop with the desktop edition of .NET runtime. On Windows, you either need to build the static library, or include that .cpp into the build system of the consuming project.A small C++ demo is implemented in NativeLibrary project. On Windows, the NativeLibrary.vcxproj project builds comtest.dll. Only tested with Visual Studio 2017.On Linux, that project builds builds libcomtest.so. It uses cmake. Only tested with gcc 8.2.0, should be portable to any C++/14 compiler.When building on Windows, my implementation is binary compatible with Microsoft’s COM. ComLightDesktop project builds a Windows console application which consumes an object from that dll using the built-in COM interop from the desktop version of .NET framework.The managed side of the interop is implemented in ComLight project. It targets .NET core 2.2. Tested on both Windows and Linux. PortableClient project builds a cross-platform test application.## How it WorksI'm using Reflection.Emit to build delegate types, marked with `[UnmanagedFunctionPointer]` attribute. The delegates have one more parameter of type `IntPtr`, for the native `this` pointer. I copy the rest of the parameters from the managed interface methods, along with their custom attributes, if any.Then I use [Marshal.GetDelegateForFunctionPointer](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.getdelegateforfunctionpointer?view=netframework-4.8) with these delegates to expose a C++ object to .NET, or [Marshal.GetFunctionPointerForDelegate](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.getfunctionpointerfordelegate?view=netframework-4.8) to build virtual method table wrapping a C# object for use by C++.## PerformanceThe interop code in ComLight assembly uses [Reflection.Emit](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit?view=netframework-4.8) and [System.Linq.Expressions](https://docs.microsoft.com/en-us/dotnet/api/system.linq.expressions?view=netframework-4.8) to generate boilerplate code in runtime. The generated code runs pretty fast.Specifically, on my PC, both Linux and Windows versions are spending about 20 nanoseconds per C# -> C++ call, that’s about 70 CPU cycles.The other way, calling from C++ to .NET, is even faster on Windows, 15 nanoseconds per call, about 50 cycles. Strangely enough, on Linux it’s the same 20 nanoseconds both ways.# DisclaimersI have not yet tested this in commercial projects I'm working on. Will do soon.Only tested on Windows 10 and Ubuntu Linux, 64 bit.